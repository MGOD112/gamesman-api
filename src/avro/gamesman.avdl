/**
 * The interface for a back end that provides Gamesman functionality for a set
 * of games.
 */
@namespace("edu.berkeley.gamesman.avro")
protocol GamesmanProvider {

  /**
   * The set of values that can apply to a board, from the current player's
   * perspective. Null may be used to represent unknown board values.
   */
  enum Value {
    /** Guaranteed win with optimal play even against a perfect opponent. */
    WIN,
    /** Guaranteed lose if the opponent plays perfectly. */
    LOSE,
    /** At best, a tie game against a perfect opponent. */
    TIE,
    /** At best, an infinite loop against a perfect opponent. */
    DRAW
  }

  /**
   * The set of fields that a position-value object can contain. This object
   * allows database providers to describe which fields they support for a
   * given game variant. In addition, clients may use this object to hint at
   * which fields they want from the server.
   */
  record Fields {
    boolean value = false;
    boolean remoteness = false;
    boolean winBy = false;
    boolean mex = false;
  }

  /**
   * The value of a position in a game. A position encodes a state of the game,
   * which includes the board, whose turn it is, and other information required
   * to adequately describe the game state (for example, some games have phases
   * that need to be specified). Note that many games, including Tic-Tac-Toe,
   * implicitly encode the current player in their boards.
   */
  record PositionValue {
    /** The position described by this position-value. */
    string position;
    /** The win/lose/tie/draw value of the position. */
    union {null, Value} value;
    /** The fewest moves required to reach a primitive with this value. */
    union {null, int} remoteness;
    /** The maximum score by which the current player can win. */
    union {null, float} winBy;
    /** The mex of this position. */
    union {null, int} mex;
  }

  /**
   * Returns a mapping from games to lists of supported variants for each game.
   * Each variant is represented as a mapping from property names to values.
   * <p>
   * To save memory, an implementation may choose only to include variants for
   * games that are solved. However, since such an implementation may still be
   * able to compute moves for a game, it is valid to include a mapping from
   * a game name to an empty list (that is, no variants), to indicate that the
   * game is supported to a limited degree.
   */
  map<array<map<string>>> getSupportedGames();

  /**
   * Returns the position-value of the initial position for the given game
   * variant.
   */
  PositionValue getInitialPositionValue(string game, map<string> variant,
                                        Fields fields);

  /**
   * Returns a mapping from the given positions to their respective values.
   * The specified set of fields is used to hint at which fields of the
   * position-value objects are relevant to the client.
   */
  map<PositionValue> getPositionValues(string game, map<string> variant,
                                       array<string> positions, Fields fields);

  /**
   * Returns a mapping from moves to their respective destination positions and
   * their values ({@link PositionValue} objects contain the positions they
   * describe). Each position-value is from the perspective of the player whose
   * turn it is for the respective position; the client can use this
   * information to determine the value of each move. This point is subtle.
   * <p>
   * For most games in which players alternate turns, the move-value will be
   * the opposite of the destination position-value; for example, if player X
   * makes a winning move, then player O is given a losing destination
   * position. However, some games may allow players to take consecutive turns
   * (an extreme example is a puzzle, in which only one player ever moves).
   * Therefore, if player X makes a winning move and player X remains the
   * current player for the destination position, then the value of that
   * position will be a win as well.
   */
  map<PositionValue> getNextPositionValues(string game, map<string> variant,
                                           string position, Fields fields);

  /**
   * Issues a request to solve the specified game variant. The solver may
   * contact the requestor at the given pingback URI when the solve is complete
   * or if an error occurred.
   * TODO: Specify URI query parameters for denoting successes, errors, etc...
   */
  void solve(string game, map<string> variant, string pingback) oneway;
}
